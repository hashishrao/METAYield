// This is an autogenerated file from Firebase Studio.

'use server';

/**
 * @fileOverview A flow to analyze a user's yield and suggest an auto-repayment strategy.
 *
 * - analyzeYieldStrategy - A function that handles the yield strategy analysis process.
 * - AnalyzeYieldStrategyInput - The input type for the analyzeYieldStrategy function.
 * - AnalyzeYieldStrategyOutput - The return type for the analyzeYieldStrategy function.
 */

import {ai} from '@/ai/genkit';
import {z} from 'genkit';

const AnalyzeYieldStrategyInputSchema = z.object({
  currentYield: z
    .number()
    .describe('The user\u2019s current yield as a percentage.'),
  spendingAmount: z
    .number()
    .describe('The user\u2019s typical credit card spending amount in USDC.'),
  riskTolerance: z
    .enum(['conservative', 'balanced', 'aggressive'])
    .describe('The user\u2019s risk tolerance level.'),
});
export type AnalyzeYieldStrategyInput = z.infer<
  typeof AnalyzeYieldStrategyInputSchema
>;

const AnalyzeYieldStrategyOutputSchema = z.object({
  suggestedStrategy: z
    .enum(['conservative', 'balanced', 'aggressive'])
    .describe(
      'The suggested auto-repayment strategy based on the user\u2019s input.'
    ),
  repaymentFeasibility: z
    .boolean()
    .describe(
      'Whether the suggested strategy is feasible based on the current yield and spending amount.'
    ),
  explanation: z
    .string()
    .describe(
      'A detailed explanation of why the suggested strategy was chosen and the factors considered.'
    ),
  estimatedGasFee: z
    .number()
    .describe('The estimated gas fee in USDC for the transaction.'),
  yieldCoverageRatio: z
    .number()
    .describe(
      'The ratio of projected monthly yield to the spending amount. E.g., 1.2 means yield is 120% of spending.'
    ),
});
export type AnalyzeYieldStrategyOutput = z.infer<
  typeof AnalyzeYieldStrategyOutputSchema
>;

export async function analyzeYieldStrategy(
  input: AnalyzeYieldStrategyInput
): Promise<AnalyzeYieldStrategyOutput> {
  return analyzeYieldStrategyFlow(input);
}

const prompt = ai.definePrompt({
  name: 'analyzeYieldStrategyPrompt',
  input: {schema: AnalyzeYieldStrategyInputSchema},
  output: {schema: AnalyzeYieldStrategyOutputSchema},
  prompt: `You are an AI-powered financial advisor specializing in auto-repayment strategies for crypto-backed credit cards.

  Based on the user's current yield ({{{currentYield}}}%), spending amount ({{{spendingAmount}}} USDC), and risk tolerance ({{{riskTolerance}}}), suggest an appropriate auto-repayment strategy (conservative, balanced, or aggressive).

  Consider the following factors when determining the suggested strategy and repayment feasibility:
  - **Conservative:** Prioritizes minimizing risk and ensuring repayments are always covered, even with fluctuating yields.  This may result in slower debt repayment.
  - **Balanced:** Aims for a moderate repayment pace while maintaining a reasonable safety margin against yield fluctuations.
  - **Aggressive:** Focuses on rapid repayment, even if it means taking on more risk and potentially facing insufficient yield in some periods.

  Explain your reasoning for choosing the suggested strategy and whether the repayment is feasible, given the user's current yield and spending amount. For example, if the yield barely covers the spending amount, even a conservative strategy might be deemed infeasible.

  Also, provide a realistic estimated gas fee for this USDC transaction on the Linea network (a value between 0.10 and 1.50 USDC).
  Based on the spending amount and current yield, estimate a yield coverage ratio. A ratio of 1.0 means the yield exactly covers the spending. A ratio above 1.0 is a surplus, and below 1.0 is a deficit. This ratio is critical for determining feasibility.

  The output should be formatted as JSON. Ensure all fields in the output schema are set.
`,
});

const analyzeYieldStrategyFlow = ai.defineFlow(
  {
    name: 'analyzeYieldStrategyFlow',
    inputSchema: AnalyzeYieldStrategyInputSchema,
    outputSchema: AnalyzeYieldStrategyOutputSchema,
  },
  async input => {
    const {output} = await prompt(input);
    return output!;
  }
);
